Process là gì?
    Process là một chương trình đang chạy trên hệ điều hành.
    Mỗi process có: bộ nhớ riêng, stack, heap, và một hoặc nhiều thread.
    Ví dụ: Mở trình duyệt Chrome, mở Excel → mỗi ứng dụng là một process.

Thread là gì?
    Thread là luồng thực thi nhỏ nhất bên trong process.
    Các thread trong cùng process chia sẻ bộ nhớ heap nhưng stack riêng.
    Ví dụ: Trong Chrome, mỗi tab là một thread, nhưng cùng dùng chung heap của process Chrome.

Có bao nhiêu cách tạo thread trong Java?
    Cách 1:  Kế thừa Thread class
        class MyThread extends Thread {
            public void run() {
                System.out.println("Thread chạy: " + Thread.currentThread().getName());
            }
        }

        public class Demo {
            public static void main(String[] args) {
                MyThread t = new MyThread();
                t.start(); // gọi start() để chạy thread
            }
        }

    Cách 2: Implement Runnable interface
        class MyRunnable implements Runnable {
            public void run() {
                System.out.println("Thread chạy: " + Thread.currentThread().getName());
            }
        }

        public class Demo {
            public static void main(String[] args) {
                Thread t = new Thread(new MyRunnable());
                t.start();
            }
        }

| Tiêu chí              | Kế thừa `Thread`                                | Dùng `Runnable` / Lambda                              |
| --------------------- | ----------------------------------------------- | ----------------------------------------------------- |
| **Cách tạo**          | Tạo lớp con của `Thread`, override `run()`      | Tạo `Runnable` (hoặc lambda) và truyền vào `Thread`   |
| **Tạo object thread** | `Thread t = new MyThread();`                    | `Thread t = new Thread(runnable);`                    |
| **Logic thread**      | Nằm trực tiếp trong lớp con                     | Nằm trong `Runnable`, tách biệt thread                |
| **Tái sử dụng logic** | Khó, logic gắn với lớp riêng                    | Dễ, cùng 1 `Runnable` chạy nhiều thread               |
| **Kế thừa lớp khác**  | Không được (Java chỉ hỗ trợ single inheritance) | Được, class vẫn có thể kế thừa lớp khác               |
| **Phù hợp với**       | Thread đơn giản, nhanh                          | Nhiều thread, logic reusable, kết hợp ExecutorService |


Thế nào là multi thread ? Sử dụng multi thread mang lại ưu nhược điểm gì ?
Multi-threading là chạy nhiều thread song song trong cùng 1 process.
    Ưu điểm:
        Tận dụng CPU đa nhân
        Giảm thời gian chờ I/O
        Cải thiện trải nghiệm người dùng (UI không bị block)
    Nhược điểm:
        Phức tạp, dễ lỗi race condition
        Đồng bộ dữ liệu cần lock → overhead
        Khó debug, dễ deadlock

Làm sao biết thread đã hoàn thành?
https://stackoverflow.com/questions/702415/how-to-know-if-other-threads-have-finished
    .join() sử dụng để biết thread này chạy xong chưa rồi chạy tiếp thread chính
    .isAlive()
    .getState()
        NEW → chưa start
        RUNNABLE → đang chạy hoặc sẵn sàng chạy
        BLOCKED → đang bị khóa
        WAITING → đang chờ signal
        TIMED_WAITING → đang chờ timeout
        TERMINATED → đã kết thúc

| Cách kiểm tra              | Cách sử dụng                      | Chặn thread gọi kiểm tra?      | Ưu điểm                                    | Nhược điểm                             | Khi nên dùng                                                      |
| -------------------------- | --------------------------------- | ------------------------------ | ------------------------------------------ | -------------------------------------- | ----------------------------------------------------------------- |
| `Thread.isAlive()`         | `t.isAlive()`                     | Không                          | Kiểm tra trạng thái bất cứ lúc nào         | Phải lặp kiểm tra liên tục để theo dõi | Khi muốn **giám sát trạng thái thread**, không cần chặn           |
| `Thread.join()`            | `t.join()` hoặc `t.join(timeout)` | Có                             | Đảm bảo thread hoàn tất trước khi tiếp tục | Chặn thread gọi join                   | Khi cần **đồng bộ hóa luồng**, chờ thread xong trước khi tiếp tục |
| `ExecutorService + Future` | `future.isDone()`, `future.get()` | `get()` chặn, `isDone()` không | Dùng với thread pool, nhận kết quả thread  | Phải dùng executor, hơi phức tạp hơn   | Khi dùng **thread pool, Callable**, hoặc cần **kết quả trả về**   |


Giới hạn số thread trong Java?
    Không có giới hạn cứng, nhưng bị hạn chế bởi:
        Bộ nhớ stack của từng thread
        Số lượng tài nguyên hệ thống
    Ví dụ: Tạo quá nhiều thread (>10,000) có thể OutOfMemoryError: unable to create new native thread

Thread Pool
    là một tập hợp các thread đã được khởi tạo sẵn để thực hiện các task, thay vì tạo thread mới mỗi lần cần chạy công việc.
    Ý tưởng
        Thay vì tạo thread mới liên tục → tốn tài nguyên, chậm, có thể gây OutOfMemoryError.
        Thread pool tái sử dụng các thread đã tạo sẵn để chạy các task khác nhau.
        Khi task kết thúc → thread không chết mà trở lại pool, sẵn sàng chạy task tiếp theo.
    2️⃣ Lợi ích
    Tiết kiệm tài nguyên: không phải tạo và hủy thread liên tục.
        Quản lý số thread: giới hạn số lượng thread tối đa, tránh quá tải CPU.
        Quản lý task: các task được xếp hàng (queue), thread pool xử lý tuần tự hoặc song song.
        Tái sử dụng logic thread: thread không chết sau khi task xong, có thể chạy task khác.